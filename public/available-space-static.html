<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Available Space (Static) - P-1-B 123</title>
  <link rel="stylesheet" href="/css/kiosk.css">
  <link rel="stylesheet" href="/css/available-space.css">
  <style>
    /* Enhanced styles for 40-inch TV display - RESPONSIVE FIT */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* No scrolling allowed */
    }

    :root {
      --tv-header-height: 70px;
      --tv-info-box-height: 170px;
      --tv-cell-size: auto; /* Will be calculated */
      --tv-font-size: clamp(0.7rem, 1.2vw, 1.2rem); /* Responsive font size */
    }

    .kiosk-container.available-space-page {
      padding: 10px 20px;
      background: linear-gradient(135deg, #1a252f 0%, #232F3E 50%, #2a3a4a 100%);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .available-space-page .header {
      height: var(--tv-header-height);
      margin-bottom: 10px;
      background: linear-gradient(135deg, #2d3e50 0%, #34495e 100%);
      border-bottom: 3px solid var(--amazon-orange);
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      flex-shrink: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 clamp(20px, 3vw, 40px);
    }

    .available-space-page #side-title {
      font-size: clamp(1.5rem, 3vw, 2.5rem);
      font-weight: 900;
      letter-spacing: 2px;
      text-shadow: 0 0 20px rgba(255, 153, 0, 0.8), 2px 2px 4px rgba(0,0,0,0.5);
    }

    .available-space-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0; /* Critical for flexbox with overflow */
    }

    #space-grid-container {
      font-size: var(--tv-font-size);
      border: 2px solid rgba(255, 153, 0, 0.3);
      border-radius: 8px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.5);
      background: linear-gradient(135deg, #1e2936 0%, #232F3E 100%);
      flex: 1;
      overflow: hidden; /* No scrollbar */
      display: grid;
      min-height: 0;
    }

    .grid-cell {
      padding: clamp(4px, 1vh, 8px) clamp(4px, 0.5vw, 6px);
      font-size: var(--tv-font-size);
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .grid-cell:hover {
      background-color: rgba(255, 153, 0, 0.15);
      transform: scale(1.05);
      z-index: 10;
    }

    .header-cell {
      font-size: clamp(0.8rem, 1.5vw, 1.15rem);
      font-weight: 700;
      background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
      border-bottom: 2px solid rgba(255, 153, 0, 0.3);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .aisle-header {
      letter-spacing: 1px;
    }

    .section-label-cell {
      font-size: clamp(1rem, 1.8vw, 1.3rem);
      font-weight: 800;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      color: var(--amazon-orange);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      border-right: 3px solid rgba(255, 153, 0, 0.4);
    }

    .bin-percent {
      font-size: clamp(0.75rem, 1.2vw, 1.05rem);
      font-weight: 700;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
      letter-spacing: 0.5px;
    }

    .bin-percent.bin-color-red {
      color: #FF5252;
      text-shadow: 0 0 8px rgba(255, 82, 82, 0.5), 1px 1px 3px rgba(0,0,0,0.8);
    }

    .bin-percent.bin-color-yellow {
      color: #FFD740;
      text-shadow: 0 0 8px rgba(255, 215, 64, 0.5), 1px 1px 3px rgba(0,0,0,0.8);
    }

    .bin-percent.bin-color-green {
      color: #69F0AE;
      text-shadow: 0 0 8px rgba(105, 240, 174, 0.5), 1px 1px 3px rgba(0,0,0,0.8);
    }

    .shaded-section-row .grid-cell {
      background-color: rgba(0, 0, 0, 0.2);
    }

    .additional-info-container {
      margin-top: clamp(10px, 2vh, 20px);
      gap: clamp(15px, 2vw, 25px);
      height: var(--tv-info-box-height);
      flex-shrink: 0;
    }

    .info-box {
      padding: clamp(10px, 2vh, 15px) clamp(20px, 3vw, 30px);
      background: linear-gradient(135deg, rgba(45, 62, 80, 0.6) 0%, rgba(35, 47, 62, 0.8) 100%);
      border: 2px solid rgba(255, 153, 0, 0.3);
      border-radius: 12px;
      box-shadow: 0 6px 25px rgba(0,0,0,0.4), inset 0 1px 3px rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      min-width: 0; /* Allow flexbox to shrink */
      overflow: hidden; /* Prevent content overflow */
    }

    .info-box h3 {
      font-size: clamp(1rem, 1.8vw, 1.3rem);
      margin-bottom: clamp(6px, 0.8vh, 10px);
      padding-bottom: clamp(4px, 0.8vh, 6px);
      border-bottom: 2px solid rgba(255, 153, 0, 0.5);
      color: var(--amazon-orange);
      text-shadow: 0 0 10px rgba(255, 153, 0, 0.4);
      font-weight: 800;
      letter-spacing: 1px;
    }

    .info-box ul {
      font-size: clamp(0.85rem, 1.4vw, 1rem);
      line-height: 1.5;
      overflow: hidden; /* Prevent text overflow */
      word-wrap: break-word;
      margin: 0;
      padding: 0;
    }

    .info-box li {
      margin-bottom: clamp(3px, 0.5vh, 5px);
      padding: clamp(2px, 0.4vh, 4px) 0;
      color: #e0e0e0;
      font-weight: 500;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .info-box p {
      font-size: clamp(0.9rem, 1.5vw, 1rem);
      color: #b0b0b0;
      font-style: italic;
    }

    .color-swatch {
      width: clamp(14px, 2vw, 18px);
      height: clamp(14px, 2vw, 18px);
      border-radius: 4px;
      margin-right: clamp(6px, 1vw, 8px);
      border: 2px solid rgba(255, 255, 255, 0.4);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .color-swatch.red { 
      background-color: #FF5252;
      box-shadow: 0 0 10px rgba(255, 82, 82, 0.5);
    }
    .color-swatch.yellow { 
      background-color: #FFD740;
      box-shadow: 0 0 10px rgba(255, 215, 64, 0.5);
    }
    .color-swatch.green { 
      background-color: #69F0AE;
      box-shadow: 0 0 10px rgba(105, 240, 174, 0.5);
    }

    .loading-message {
      font-size: clamp(1.2rem, 2.5vw, 1.8rem);
      padding: clamp(40px, 8vh, 80px);
      color: var(--amazon-orange);
      text-shadow: 0 0 10px rgba(255, 153, 0, 0.5);
    }

    /* Add visual separator line between sections */
    .grid-mid-header-row .mid-aisle-header {
      background: linear-gradient(135deg, #FF9900 0%, #FFB84D 100%);
      color: #1a252f;
      font-weight: 800;
      font-size: 0.95rem;
      border-top: 3px solid rgba(255, 153, 0, 0.6);
      border-bottom: 3px solid rgba(255, 153, 0, 0.6);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    .mid-corner-cell {
      background: linear-gradient(135deg, #FF9900 0%, #FFB84D 100%);
      border-top: 3px solid rgba(255, 153, 0, 0.6);
      border-bottom: 3px solid rgba(255, 153, 0, 0.6);
    }

    .cell-before-gap {
      border-right: 4px solid rgba(255, 153, 0, 0.4);
    }

    .cell-after-gap {
      border-left: 4px solid rgba(255, 153, 0, 0.4);
    }

    /* Add subtle animation to grid */
    @keyframes gridFadeIn {
      from { opacity: 0; transform: scale(0.98); }
      to { opacity: 1; transform: scale(1); }
    }

    #space-grid-container {
      animation: gridFadeIn 0.6s ease-out;
    }

    /* Make the bottom header row match the top */
    .bottom-aisle-header {
      background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
      font-size: 1.15rem;
      font-weight: 700;
      border-top: 2px solid rgba(255, 153, 0, 0.3);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    /* Add subtle pulse animation to high-value cells */
    @keyframes cellPulse {
      0%, 100% { box-shadow: inset 0 0 5px rgba(105, 240, 174, 0.3); }
      50% { box-shadow: inset 0 0 10px rgba(105, 240, 174, 0.5); }
    }

    /* Enhanced data cell styling with better depth */
    .data-cell {
      position: relative;
      overflow: hidden;
    }

    .data-cell::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, transparent 100%);
      pointer-events: none;
    }

    /* Better grid border visibility */
    .grid-cell {
      border-right: 1px solid rgba(255, 255, 255, 0.15);
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
    }

    /* Add a subtle grid pattern overlay */
    #space-grid-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        linear-gradient(rgba(255, 153, 0, 0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 153, 0, 0.02) 1px, transparent 1px);
      background-size: 20px 20px;
      pointer-events: none;
      opacity: 0.5;
    }

    #space-grid-container {
      position: relative;
    }

    /* Improve corner cell styling */
    .corner-cell, .corner-cell-right, .bottom-corner-cell {
      background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
    }

    /* Add responsive legend box styling */
    .legend-box {
      flex: 1.2;
      min-width: 0; /* Allow flexbox to shrink */
    }

    /* Ensure info boxes are equally sized */
    .additional-info-container > div {
      flex: 1;
      min-width: 0; /* Allow flexbox to shrink and prevent overflow */
    }

    /* Add subtle scan line effect for that authentic kiosk feel */
    @keyframes scanLine {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100vh); }
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(to bottom, transparent, rgba(255, 153, 0, 0.1), transparent);
      animation: scanLine 8s linear infinite;
      pointer-events: none;
      z-index: 9999;
      opacity: 0.3;
    }
  </style>
</head>
<body>
  <div class="kiosk-container available-space-page">
    <div class="header">
      <div class="logo" style="flex: 1; display: flex; justify-content: center;">
        <span id="side-title">P-1-B 123</span>
      </div>
      <div id="data-timestamp" style="font-size: clamp(0.85rem, 1.5vw, 1rem); color: #b0b0b0; padding: clamp(8px, 1.5vh, 12px) clamp(16px, 2vw, 24px); background: rgba(0,0,0,0.3); border-radius: 6px; border: 1px solid rgba(255, 153, 0, 0.2); display: flex; align-items: center;">
        <span style="color: #69F0AE; margin-right: clamp(4px, 0.5vw, 8px);">‚óè</span>
        <span id="timestamp-text">Loading...</span>
      </div>
    </div>
    <div class="content available-space-content">
      <div id="space-grid-container">
          <!-- Grid will be rendered here by JS -->
          <p class="loading-message">‚ö° Generating space data...</p>
      </div>
      <div class="additional-info-container" style="display: flex; gap: 20px; margin-top: 20px;">
        <div class="legend-box info-box">
          <h3>üéØ Color Legend</h3>
          <div style="display: flex; flex-direction: column; gap: clamp(4px, 0.6vh, 8px); font-size: clamp(0.85rem, 1.4vw, 1rem);">
            <div style="display: flex; align-items: center;">
              <span class="color-swatch green"></span>
              <span style="font-weight: 600;">Best (Most Empty)</span>
              <span style="margin-left: auto; opacity: 0.8;">(Bottom 25%)</span>
            </div>
            <div style="display: flex; align-items: center;">
              <span class="color-swatch yellow"></span>
              <span style="font-weight: 600;">Medium</span>
              <span style="margin-left: auto; opacity: 0.8;">(Middle 50%)</span>
            </div>
            <div style="display: flex; align-items: center;">
              <span class="color-swatch red"></span>
              <span style="font-weight: 600;">Worst (Most Full)</span>
              <span style="margin-left: auto; opacity: 0.8;">(Top 25%)</span>
            </div>
          </div>
        </div>
        <div class="empty-bins info-box" id="empty-bins"></div>
        <div class="best-sections info-box" id="best-sections"></div>
      </div>
    </div>
  </div>

  <script>
    // Static Available Space Data and Rendering Logic

    let spaceData = null;
    let overallAvailability = {};
    let binTypeColors = {};

    // --- Data Processing & Relative Threshold Calculation ---
    let P25 = 0;
    let P75 = 0;

    function calculateRelativeThresholds(aisles) {
        if (!aisles || aisles.length === 0) return;

        const allValues = [];
        aisles.forEach(aisle => {
            Object.values(aisle.sections).forEach(section => {
                Object.values(section).forEach(bin => {
                    allValues.push(bin.availability);
                });
            });
        });

        if (allValues.length === 0) return;

        allValues.sort((a, b) => a - b);

        const p25Index = Math.floor(allValues.length * 0.25);
        const p75Index = Math.floor(allValues.length * 0.75);

        P25 = allValues[p25Index];
        // Ensure P75 is distinct from P25, especially with clustered data
        // Find the first value *strictly greater* than P25 at or after the P75 index if needed
        let actualP75Index = p75Index;
        while(actualP75Index < allValues.length -1 && allValues[actualP75Index] <= P25) {
             actualP75Index++;
        }
        P75 = allValues[actualP75Index];
        
        // Handle edge case where all values might be the same
        if (P75 <= P25 && allValues.length > 0) {
            P75 = P25 + 1; // Make P75 slightly higher so yellow/green are possible
        }

        console.log(`Calculated Relative Thresholds: P25=${P25}, P75=${P75}`);
    }

    // --- Static Data Generation ---
    function generateStaticSpaceData() {
        const numAisles = 25;
        const aisles = [];
        const binTypes = ['Library', 'Library Deep'];

        // Helper to generate clustered availability around a target
        function getClusteredValue(target, range = 15) {
            const min = Math.max(50, target - range); // Ensure minimum 50%
            const max = Math.min(98, target + range); // Keep below 100% for realism
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Define some 'hotspot' targets for clustering
        const clusterTargets = [
            { startAisle: 2, endAisle: 5, target: 85 },   // High availability zone 1
            { startAisle: 10, endAisle: 14, target: 65 }, // Medium availability zone
            { startAisle: 18, endAisle: 22, target: 90 }, // High availability zone 2
        ];
        const defaultTarget = 55; // Default for areas outside clusters

        for (let i = 0; i < numAisles; i++) {
            const aisleId = i + 1;
            const aisleData = { id: aisleId, sections: {} };
            let currentTarget = defaultTarget;

            // Check if aisle falls into a cluster
            for (const cluster of clusterTargets) {
                if (aisleId >= cluster.startAisle && aisleId <= cluster.endAisle) {
                    currentTarget = cluster.target;
                    break;
                }
            }

            const sections = [100, 200, 300, 400, 500, 600, 700, 800];
            sections.forEach(sectionId => {
                aisleData.sections[sectionId] = {
                    top: { type: binTypes[Math.floor(Math.random() * 2)], availability: getClusteredValue(currentTarget) },
                    middle: { type: binTypes[Math.floor(Math.random() * 2)], availability: getClusteredValue(currentTarget) },
                    bottom: { type: binTypes[Math.floor(Math.random() * 2)], availability: getClusteredValue(currentTarget) }
                };
                // Slightly decay target towards default for next section to blend zones
                currentTarget = Math.round(currentTarget * 0.95 + defaultTarget * 0.05);
                currentTarget = Math.max(50, currentTarget); // Keep above 50
            });
            aisles.push(aisleData);
        }

        // Calculate emptyBins and bestSections based on generated data (though likely few/none >50%)
        const emptyBins = []; // Will likely be empty as we target >50%
        const bestSections = { Library: { aisle: 1, section: '100', availability: 100 }, 'Library Deep': { aisle: 1, section: '100', availability: 100 }};

        aisles.forEach(aisle => {
            Object.entries(aisle.sections).forEach(([section, bins]) => {
                ['top', 'middle', 'bottom'].forEach(position => {
                    const bin = bins[position];
                    if (bin.availability === 100) { // Unlikely but check
                        emptyBins.push({ aisle: aisle.id, section, position, type: bin.type });
                    }
                    // LOWER availability is BETTER (more empty space)
                    if (bestSections[bin.type] && bin.availability < bestSections[bin.type].availability) {
                        bestSections[bin.type] = { aisle: aisle.id, section, availability: bin.availability };
                    }
                });
            });
        });
        
        console.log("Generated static space data:", { aisles, emptyBins, bestSections });
        return { aisles, emptyBins, bestSections };
    }

    // --- Data Processing (Averages - Keep as is for Info Box) ---
    function calculateOverallAvailability(aisles) {
        const totals = {};
        if (!aisles) return {};
        aisles.forEach(aisle => {
            Object.values(aisle.sections).forEach(section => {
                Object.values(section).forEach(bin => {
                    if (!totals[bin.type]) {
                        totals[bin.type] = { available: 0, count: 0 };
                    }
                    totals[bin.type].available += bin.availability;
                    totals[bin.type].count += 1;
                });
            });
        });
        const averages = {};
        for (const type in totals) {
            averages[type] = totals[type].count > 0 ? Math.round(totals[type].available / totals[type].count) : 0;
        }
        console.log("Overall Average Availability:", averages);
        return averages;
    }

    function determineBinTypeColors(availabilityAverages) {
         const colors = {};
        for (const type in availabilityAverages) {
            const avg = availabilityAverages[type];
            // LOWER percentage = BETTER (more empty space)
            if (avg < 25) {        // 0-24% = Green (nearly empty, best)
                 colors[type] = 'green';
            } else if (avg < 50) { // 25-49% = Yellow (medium)
                 colors[type] = 'yellow';
            } else {              // 50-100% = Red (mostly full, worst)
                 colors[type] = 'red';
            }
        }
        console.log("Bin Type Colors:", colors);
        return colors;
    }

    // --- Rendering Functions (Copied from original, slightly modified) ---
    function renderSpaceGrid() {
        if (!spaceData || !spaceData.aisles) {
            console.warn("No aisle data available to render grid.");
            const container = document.getElementById('space-grid-container');
            if (container) container.innerHTML = '<p class="loading-message">Error: No static data to render.</p>';
            return;
        }
        const container = document.getElementById('space-grid-container');
        container.innerHTML = ''; // Clear previous grid
        const numAisles = spaceData.aisles.length;
        const columnHeaders = ['148', '146', '144', '142', '140', '138', '136', '134', '132', '130', '128', '126', '124', '122', '120', '118', '116', '114', '112', '110', '108', '106', '104', '102', '100'];

        container.style.setProperty('--num-aisles', numAisles);
        // Adjust grid template columns to include the two section label columns
        container.style.gridTemplateColumns = `auto repeat(${numAisles}, 1fr) auto`;

        const sections = ['100', '200', '300', '400', '500', '600', '700', '800'];
        const positions = ['top', 'middle', 'bottom'];

        // 1. Create Aisle Header Row
          const headerRow = document.createElement('div');
          headerRow.className = 'grid-header-row';
          const cornerCell = document.createElement('div');
          cornerCell.className = 'grid-cell header-cell corner-cell';
          headerRow.appendChild(cornerCell);
          columnHeaders.slice(0, numAisles).forEach((headerText, index) => { // Use slice to avoid index out of bounds
              const headerCell = document.createElement('div');
              headerCell.className = 'grid-cell header-cell aisle-header';
              headerCell.textContent = headerText;
              if (index === 11) headerCell.classList.add('cell-before-gap');
              if (index === 12) headerCell.classList.add('cell-after-gap');
              headerRow.appendChild(headerCell);
          });
          const cornerCellRight = document.createElement('div');
          cornerCellRight.className = 'grid-cell header-cell corner-cell corner-cell-right';
          headerRow.appendChild(cornerCellRight);
          container.appendChild(headerRow);


        // 2. Create Data Rows
          sections.forEach((sectionId) => {
              positions.forEach((posKey, posIndex) => {
                  const dataRow = document.createElement('div');
                  dataRow.className = 'grid-data-row';
                  const sectionNum = parseInt(sectionId);
                  if (sectionNum === 100 || sectionNum === 300 || sectionNum === 500 || sectionNum === 700) {
                      dataRow.classList.add('shaded-section-row');
                  }

                  // Add Section Header Cell (Left)
                  if (posIndex === 0) {
                      const sectionHeaderCell = document.createElement('div');
                      sectionHeaderCell.className = 'grid-cell header-cell section-header section-label-cell';
                      sectionHeaderCell.textContent = sectionId;
                      sectionHeaderCell.style.gridRow = `span ${positions.length}`;
                      dataRow.appendChild(sectionHeaderCell);
                  }

                  // Add Data Cells
                  spaceData.aisles.forEach((aisle, aisleIndex) => {
                      const headerIndex = aisleIndex;
                      if (headerIndex >= columnHeaders.length) return;
                      const binData = aisle.sections[sectionId]?.[posKey];
                      const dataCell = document.createElement('div');
                      dataCell.className = 'grid-cell data-cell';
                      if (headerIndex === 11) dataCell.classList.add('cell-before-gap');
                      if (headerIndex === 12) dataCell.classList.add('cell-after-gap');

                      if (binData) {
                          const percentageSpan = document.createElement('span');
                          percentageSpan.className = 'bin-percent';
                          percentageSpan.textContent = `${binData.availability}%`;
                          percentageSpan.title = `${binData.type} (${posKey}) - ${binData.availability}%`;
                          let colorClass = 'bin-color-unknown';
                          // Relative Coloring Logic: LOW = GOOD (Green), HIGH = BAD (Red)
                          if (binData.availability <= P25) {          // Bottom 25% = BEST (most empty)
                              colorClass = 'bin-color-green';
                          } else if (binData.availability <= P75) { // Middle 50% = OK
                              colorClass = 'bin-color-yellow';
                          } else {                                  // Top 25% = WORST (fullest)
                              colorClass = 'bin-color-red';
                          }
                          percentageSpan.classList.add(colorClass);
                          const typeClass = binData.type.toLowerCase().replace(' ', '-');
                          dataCell.classList.add(`bin-type-${typeClass}`);
                          dataCell.appendChild(percentageSpan);
                      } else {
                          dataCell.textContent = '-';
                          dataCell.classList.add('no-data');
                      }
                      dataRow.appendChild(dataCell);
                  });

                   // Add Section Header Cell (Right)
                  if (posIndex === 0) {
                      const sectionHeaderCellRight = document.createElement('div');
                      sectionHeaderCellRight.className = 'grid-cell header-cell section-header section-label-cell';
                      sectionHeaderCellRight.textContent = sectionId;
                      sectionHeaderCellRight.style.gridRow = `span ${positions.length}`;
                      dataRow.appendChild(sectionHeaderCellRight);
                  }

                  container.appendChild(dataRow);
              });

               // Insert mid-grid header row after section 400
              if (sectionId === '400') {
                  const midHeaderRow = document.createElement('div');
                  midHeaderRow.className = 'grid-mid-header-row';
                  const midCornerCellLeft = document.createElement('div');
                  midCornerCellLeft.className = 'grid-cell header-cell mid-corner-cell';
                  midHeaderRow.appendChild(midCornerCellLeft);
                  columnHeaders.slice(0, numAisles).forEach((headerText) => { // Use slice
                      const midHeaderCell = document.createElement('div');
                      midHeaderCell.className = 'grid-cell header-cell mid-aisle-header';
                      midHeaderCell.textContent = headerText;
                      midHeaderRow.appendChild(midHeaderCell);
                  });
                  const midCornerCellRight = document.createElement('div');
                  midCornerCellRight.className = 'grid-cell header-cell mid-corner-cell';
                  midHeaderRow.appendChild(midCornerCellRight);
                  container.appendChild(midHeaderRow);
              }
          });

        // 3. Add Bottom Header Row
          const bottomHeaderRow = document.createElement('div');
          bottomHeaderRow.className = 'grid-bottom-header-row';
          const bottomCornerCellLeft = document.createElement('div');
          bottomCornerCellLeft.className = 'grid-cell header-cell bottom-corner-cell';
          bottomHeaderRow.appendChild(bottomCornerCellLeft);
          columnHeaders.slice(0, numAisles).forEach((headerText) => { // Use slice
              const bottomHeaderCell = document.createElement('div');
              bottomHeaderCell.className = 'grid-cell header-cell bottom-aisle-header';
              bottomHeaderCell.textContent = headerText;
              bottomHeaderRow.appendChild(bottomHeaderCell);
          });
          const bottomCornerCellRight = document.createElement('div');
          bottomCornerCellRight.className = 'grid-cell header-cell bottom-corner-cell';
          bottomHeaderRow.appendChild(bottomCornerCellRight);
          container.appendChild(bottomHeaderRow);
    }

    function renderInfoBoxes() {
        if (!spaceData) return;
        const emptyBinsContainer = document.getElementById('empty-bins');
        if (emptyBinsContainer) {
            emptyBinsContainer.innerHTML = '<h3>üìç Best Locations</h3>';
            if (spaceData.bestSections) {
                const list = document.createElement('ul');
                Object.entries(spaceData.bestSections).forEach(([type, section]) => {
                    const item = document.createElement('li');
                    item.textContent = `${type}: A${section.aisle} S${section.section} (${section.availability}%)`;
                    list.appendChild(item);
                });
                emptyBinsContainer.appendChild(list);
            } else {
                emptyBinsContainer.innerHTML += '<p>Calculating...</p>';
            }
        }
        const overallAvailabilityContainer = document.getElementById('best-sections');
        if (overallAvailabilityContainer) {
            overallAvailabilityContainer.innerHTML = '<h3>Overall Availability</h3>';
            if (overallAvailability && Object.keys(overallAvailability).length > 0) {
                const list = document.createElement('ul');
                Object.entries(overallAvailability).forEach(([type, avg]) => {
                    const item = document.createElement('li');
                    const color = binTypeColors[type] || 'unknown';
                    item.innerHTML = `<span class="color-swatch ${color}"></span> ${type}: <strong>${avg}%</strong>`;
                    item.title = `Overall Avg Category: ${color}`;
                    list.appendChild(item);
                });
                overallAvailabilityContainer.appendChild(list);
            } else {
                overallAvailabilityContainer.innerHTML += '<p>Calculating...</p>';
            }
        }
    }

    // --- Update Timestamp ---
    function updateTimestamp() {
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit',
            hour12: true 
        });
        const dateString = now.toLocaleDateString('en-US', { 
            month: 'short', 
            day: 'numeric' 
        });
        const timestampEl = document.getElementById('timestamp-text');
        if (timestampEl) {
            timestampEl.textContent = `${dateString} ‚Ä¢ ${timeString}`;
        }
    }

    // Update timestamp every second
    setInterval(updateTimestamp, 1000);

    // --- Initial Load ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM loaded. Generating and rendering static data.");
        updateTimestamp(); // Set initial timestamp
        
        spaceData = generateStaticSpaceData(); // Generate the static data
        if (spaceData) {
            calculateRelativeThresholds(spaceData.aisles); // Calculate P25/P75 thresholds
            overallAvailability = calculateOverallAvailability(spaceData.aisles); // For info box
            binTypeColors = determineBinTypeColors(overallAvailability); // For info box
            renderSpaceGrid();   // Render the grid (will use P25/P75)
            renderInfoBoxes(); // Render the info boxes (uses separate logic)
            updateTimestamp(); // Update timestamp after render
        } else {
             console.error("Failed to generate static space data.");
             const container = document.getElementById('space-grid-container');
             if (container) container.innerHTML = '<p class="loading-message">‚ùå Error generating static data.</p>';
        }
    });
  </script>

</body>
</html> 